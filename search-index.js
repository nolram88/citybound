var searchIndex = {};
searchIndex["allocators"] = {"doc":"This tiny crate defines a simple allocator interface.","items":[[3,"DefaultHeap","allocators","An implementation of `Allocator` that allocates using the default heap allocator",null,null],[8,"Allocator","","A trait for all allocators that collections can be generic about",null,null],[10,"allocate","","Allocate enough memory to store `capacity` of `T`",0,null],[10,"deallocate","","Free previously allocated memory from pointer.",0,null],[11,"allocate","","",1,null],[11,"deallocate","","",1,null]],"paths":[[8,"Allocator"],[3,"DefaultHeap"]]};
searchIndex["chunked"] = {"doc":"This crate offers an abstraction over allocating fixed-size chunks of memory and different low-level collection types making use of these chunks to emulate \"infinite\" dynamically growing storage.","items":[[3,"MemChunker","chunked","Implementation of `Chunker` for temporary heap memory",null,null],[3,"ValueInChunk","","A simple value, stored in a chunk. Typically used to store metadata of collections (such as length) using the same kind of (non-)persistence as the items of the collection",null,null],[3,"SizedChunkedArena","","A simple array-like collection of fixed-size items of unknown type",null,null],[12,"chunker","","Chunker which is used to create and destroy chunks as needed",0,null],[12,"chunks","","List of allocated chunks",0,null],[12,"item_size","","Item size in bytes",0,null],[3,"ChunkedVec","","A vector which stores items of a known type in a `SizedChunkedArena`",null,null],[3,"ChunkedQueue","","A FIFO queue which stores heterogeneously sized items",null,null],[3,"MultiSized","","Based on a collection type for fixed-size items (\"Bin\"), creates a collection for heterogenously-sized items which will be stored in the most appropriately-sized bin.",null,null],[12,"bins","","All fixed-size bins in this multi-sized collection",1,null],[8,"Chunker","","Describes a strategy for creation and destruction of chunks, adhering to configurable settings",null,null],[10,"chunk_size","","Get the set chunk size",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"name","","Get the set chunk name root",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[10,"with_chunk_size","","Create an identical chunker, but with different chunk size",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[10,"with_name","","Create an identical chunker, but with a different name",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"child","","Create an identical chunker, with the name of the current chunker extended by a suffix.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[10,"create_chunk","","Create a new chunk with the set chunk size",2,null],[11,"load_chunk","","Load a persisted chunk that was previously created by this chunker, given an index to identify the particular chunk. Note: the default implementation just creates a new, empty chunk",2,null],[10,"destroy_chunk","","Destroys a chunk that was created by this chunker as well as any persisted representation of the chunk.",2,null],[8,"SizedChunkedCollection","","Any kind of dynamically-growing collection of fixed-size items that uses chunks",null,null],[10,"new","","Create a new collection based on a chunker and item size",3,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"memchunker"}}],[11,"from_settings","","Create a new `MemChunker` with the given settings",4,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"box"}}],[11,"chunk_size","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"name","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"with_chunk_size","","",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"box"}}],[11,"with_name","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"child","","",4,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"box"}}],[11,"create_chunk","","",4,null],[11,"destroy_chunk","","",4,null],[11,"new","","Create a new value with a given default. The default is used if no persisted chunk for this value was found.",5,{"inputs":[{"name":"box"},{"name":"t"}],"output":{"name":"valueinchunk"}}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"len","","Number of elements in the collection",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the collection empty?",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Allocate space for a new item, returns a pointer to where the new item can be written to and the index that the new item will have.",0,null],[11,"pop_away","","Remove the last item from the end",0,{"inputs":[{"name":"self"}],"output":null}],[11,"swap_remove","","Remove the item at index, by swapping it with the last item and then popping, returning the removed item, if it existed.",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"option"}}],[11,"at","","Get a pointer to the item at `index`",0,null],[11,"at_mut","","Get a mutable pointer to the item at `index`",0,null],[11,"new","","",0,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"new","","Create a new chunked vector",6,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Get the number of elements in the vector",6,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the chunked vector empty?",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"at","","Get a reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"at_mut","","Get a mutable reference to the item at `index`",6,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"item"}}],[11,"push","","Push an item onto the vector",6,{"inputs":[{"name":"self"},{"name":"item"}],"output":null}],[11,"pop","","Remove and return the last item, if the vector wasn't empty",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"new","","Create a new chunked queue based on a chunker",7,{"inputs":[{"name":"box"}],"output":{"name":"self"}}],[11,"len","","Number of items in the queue",7,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the queue empty?",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"enqueue","","Enqueue an item of a given size. Returns a pointer that the item can be written to.",7,null],[11,"dequeue","","Dequeue an item. Returns a pointer to the item in the queue, unless the queue is empty.",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop_old_chunks","","Delete chunks which have already been read",7,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Create a new `MultiSized` collection using the given chunker as a main chunker and a base size that represents the smallest expected item size (this will be used as the item size of the smallest-sized Bin)",1,{"inputs":[{"name":"box"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size_to_index","","Get the index of the Bin which stores items of size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"bin_for_size_mut","","Get a reference to the Bin most appropriately sized given item size `size`",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"b"}}]],"paths":[[3,"SizedChunkedArena"],[3,"MultiSized"],[8,"Chunker"],[8,"SizedChunkedCollection"],[3,"MemChunker"],[3,"ValueInChunk"],[3,"ChunkedVec"],[3,"ChunkedQueue"]]};
searchIndex["compact"] = {"doc":"This crate makes it possible to store objects containing dynamic fields either compactly in consecutive memory or using traditional heap pointers.","items":[[3,"CVec","compact","A dynamically-sized vector that can be stored in compact sequential storage and automatically spills over into free heap storage using `Allocator`. Tries to closely follow the API of `std::vec::Vec`, but is not complete.",null,null],[3,"CDict","","A simple linear-search key-value dictionary, implemented using two `CompactVec`'s, one for keys, one for values.",null,null],[11,"len","","Get the number of elements in the vector",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the vector empty?",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty vector",0,{"inputs":[],"output":{"name":"compactvec"}}],[11,"with_capacity","","Create a new, empty vector with a given capacity",0,{"inputs":[{"name":"usize"}],"output":{"name":"compactvec"}}],[11,"push","","Push an item onto the vector, spills onto the heap if the capacity in compact storage is insufficient",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"pop","","Pop and return the last element, if the vector wasn't empty",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"insert","","Insert a value at `index`, copying the elements after `index` upwards",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"t"}],"output":null}],[11,"remove","","Remove the element at `index`, copying the elements after `index` downwards",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"t"}}],[11,"retain","","Take a function which returns whether an element should be kept, and mutably removes all elements from the vector which are not kept",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"truncate","","Truncate the vector to the given length",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"clear","","Clear the vector",0,{"inputs":[{"name":"self"}],"output":null}],[11,"from","","Create a `CompactVec` from a normal `Vec`, directly using the backing storage as free heap storage",0,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"drop","","Drop elements and deallocate free heap storage, if any is allocated",0,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"into_iter","","",0,null],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"decompact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"is_still_compact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"compactvec"}}],[11,"from_iter","","",0,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"default","","",0,{"inputs":[],"output":{"name":"compactvec"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create new, empty dictionary",1,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Amount of entries in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Is the dictionary empty?",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Look up the value for key `query`, if it exists",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mru","","Lookup up the value for key `query`, if it exists, but also swap the entry to the beginning of the key/value vectors, so a repeated lookup for that item will be faster",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"get_mfu","","Lookup up the value for key `query`, if it exists, but also swap the entry one index towards the beginning of the key/value vectors, so frequently repeated lookups for that item will be faster",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"contains_key","","Does the dictionary contain a value for `query`?",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"bool"}}],[11,"insert","","Insert new value at key `query` and return the previous value at that key, if any existed",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"option"}}],[11,"remove","","Remove value at key `query` and return it, if it existed",1,{"inputs":[{"name":"self"},{"name":"k"}],"output":{"name":"option"}}],[11,"keys","","Iterator over all keys in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values","","Iterator over all values in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"values_mut","","Iterator over mutable references to all values in the dictionary",1,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"pairs","","Iterator over all key-value pairs in the dictionary",1,null],[11,"push_at","","Push a value onto the `CompactVec` at the key `query`",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"i"}],"output":null}],[11,"get_iter","","Iterator over the `CompactVec` at the key `query`",1,null],[11,"remove_iter","","Remove the `CompactVec` at the key `query` and iterate over its elements (if it existed)",1,null],[11,"is_still_compact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",1,null],[11,"decompact","","",1,{"inputs":[{"name":"self"}],"output":{"name":"compactdict"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","Construct a compact dictionary from an interator over key-value pairs",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"extend","","Extend a compact dictionary from an iterator over key-value pairs",1,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[8,"Compact","","A trait for objects with a statically-sized part and a potential dynamically-sized part that can be stored both compactly in consecutive memory or freely on the heap",null,null],[10,"is_still_compact","","Is the object's dynamic part stored compactly?",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"dynamic_size_bytes","","Size of the dynamic part in bytes",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"compact_from","","Copy the static part of `source` to `self` and compactly store the dynamic part of `source` as the new dynamic part of `self` at `new_dynamic_part`.",2,null],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",2,null],[11,"compact_behind_from","","Like `compact_from` with `new_dynamic_part` set to `self.behind()`",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}],[10,"decompact","","Creates a clone of self with the dynamic part guaranteed to be stored freely.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"total_size_bytes","","Total size of the object (static part + dynamic part)",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"behind","","Get a pointer to behind the static part of `self` (commonly used place for the dynamic part)",2,null],[11,"compact_behind_from","","Like `compact_from` with `new_dynamic_part` set to `self.behind()`",2,{"inputs":[{"name":"self"},{"name":"self"}],"output":null}]],"paths":[[3,"CVec"],[3,"CDict"],[8,"Compact"]]};
searchIndex["compact_macros"] = {"doc":"Automatic `#[derive(Compact)]` macro for structs whose fields are all `Compact`","items":[[5,"derive_compact","compact_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
searchIndex["descartes"] = {"doc":"","items":[[8,"Dot","descartes","Traits of objects having a dot product.",null,null],[10,"dot","","Computes the dot (inner) product of two vectors.",0,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"n"}}],[8,"ToHomogeneous","","Traits of objects which can be put in homogeneous coordinates form.",null,null],[10,"to_homogeneous","","Gets the homogeneous coordinates form of this object.",1,{"inputs":[{"name":"self"}],"output":{"name":"u"}}],[8,"Norm","","Traits of objects having an euclidian norm.",null,null],[16,"NormType","","The scalar type for the norm (i.e. the undelying field).",2,null],[11,"norm","","Computes the norm of `self`.",2,null],[10,"norm_squared","","Computes the squared norm of `self`.",2,null],[10,"normalize","","Gets the normalized version of a copy of `v`.",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"normalize_mut","","Normalizes `self`.",2,null],[10,"try_normalize","","Gets the normalized version of a copy of `v` or `None` if the vector has a norm smaller or equal to `min_norm`. In particular, `.try_normalize(0.0)` returns `None` if the norm is exactly zero.",2,null],[10,"try_normalize_mut","","Normalized `v` or does nothing if the vector has a norm smaller or equal to `min_norm`.",2,null],[8,"Inverse","","Trait of objects having an inverse. Typically used to implement matrix inverse.",null,null],[10,"inverse","","Returns the inverse of `m`.",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[10,"inverse_mut","","In-place version of `inverse`.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"Rotate","","Trait of objects able to rotate other objects.",null,null],[10,"rotate","","Applies a rotation to `v`.",4,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"v"}}],[10,"inverse_rotate","","Applies an inverse rotation to `v`.",4,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"v"}}],[3,"Circle","","",null,null],[12,"center","","",5,null],[12,"radius","","",5,null],[3,"Line","","",null,null],[12,"start","","",6,null],[12,"direction","","",6,null],[3,"Segment","","",null,null],[12,"start","","",7,null],[12,"center_or_direction","","",7,null],[12,"end","","",7,null],[12,"length","","",7,null],[3,"Intersection","","",null,null],[12,"along_a","","",8,null],[12,"along_b","","",8,null],[12,"position","","",8,null],[3,"Band","","",null,null],[12,"path","","",9,null],[12,"width","","",9,null],[3,"BoundingBox","","",null,null],[12,"min","","",10,null],[12,"max","","",10,null],[5,"convex_hull","","",null,null],[5,"angle_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[5,"angle_along_to","","",null,{"inputs":[{"name":"v2"},{"name":"v2"},{"name":"v2"}],"output":{"name":"n"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"circle"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",5,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"distance_to","","",5,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"line"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"project_with_tolerance","","",6,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"distance_to","","",6,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"line","","",7,{"inputs":[{"name":"p2"},{"name":"p2"}],"output":{"name":"segment"}}],[11,"arc_with_direction","","",7,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"}],"output":{"name":"segment"}}],[11,"biarc","","",7,{"inputs":[{"name":"p2"},{"name":"v2"},{"name":"p2"},{"name":"v2"}],"output":{"name":"vec"}}],[11,"is_linear","","",7,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"center","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"radius","","",7,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"length","","",7,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"along","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[11,"direction_along","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[11,"start","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",7,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"end","","",7,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",7,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"reverse","","",7,{"inputs":[{"name":"self"}],"output":{"name":"segment"}}],[11,"subsection","","",7,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"shift_orthogonally","","",7,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"project_with_tolerance","","",7,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"includes","","",7,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"distance_to","","",7,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[11,"bounding_box","","",7,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"intersection"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"contains","","",5,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"band"}}],[11,"new","","",9,{"inputs":[{"name":"p"},{"name":"n"}],"output":{"name":"band"}}],[11,"outline","","",9,{"inputs":[{"name":"self"}],"output":{"name":"p"}}],[11,"outline_distance_to_path_distance","","",9,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"n"}}],[11,"contains","","",9,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[6,"N","","",null,null],[6,"V2","","",null,null],[6,"P2","","",null,null],[6,"V3","","",null,null],[6,"V4","","",null,null],[6,"P3","","",null,null],[6,"M4","","",null,null],[6,"Iso3","","",null,null],[6,"Persp3","","",null,null],[17,"MIN_START_TO_END","","",null,null],[8,"Path","","",null,null],[10,"segments","","",11,null],[10,"new","","",11,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"scan_segments","","",11,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",11,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"find_on_segment","","",11,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",11,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"Intersect","","",null,null],[10,"intersect","","",12,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"WithUniqueOrthogonal","","",null,null],[10,"orthogonal","","",13,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[8,"RelativeToBasis","","",null,null],[10,"to_basis","","",14,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"from_basis","","",14,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[8,"Into2d","","",null,null],[16,"Target","","",15,null],[10,"into_2d","","",15,null],[8,"Into3d","","",null,null],[16,"Target","","",16,null],[10,"into_3d","","",16,null],[8,"RoughlyComparable","","",null,null],[11,"is_roughly","","",17,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[10,"is_roughly_within","","",17,{"inputs":[{"name":"self"},{"name":"self"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Curve","","",null,null],[11,"project_with_max_distance","","",18,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[10,"project_with_tolerance","","",18,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"option"}}],[11,"project","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"option"}}],[11,"includes","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[10,"distance_to","","",18,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"n"}}],[8,"FiniteCurve","","",null,null],[10,"length","","",19,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[10,"along","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"p2"}}],[10,"direction_along","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"v2"}}],[10,"start","","",19,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"start_direction","","",19,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"end","","",19,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"end_direction","","",19,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[10,"reverse","","",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"subsection","","",19,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[10,"shift_orthogonally","","",19,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[8,"Shape","","",null,null],[10,"contains","","",20,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[8,"HasBoundingBox","","",null,null],[10,"bounding_box","","",21,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"orthogonal","","",22,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"to_basis","","",22,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"from_basis","","",22,{"inputs":[{"name":"self"},{"name":"v2"}],"output":{"name":"v2"}}],[11,"into_2d","","",23,{"inputs":[{"name":"self"}],"output":{"name":"v2"}}],[11,"into_2d","","",24,{"inputs":[{"name":"self"}],"output":{"name":"p2"}}],[11,"into_3d","","",22,{"inputs":[{"name":"self"}],"output":{"name":"v3"}}],[11,"into_3d","","",25,{"inputs":[{"name":"self"}],"output":{"name":"p3"}}],[11,"is_roughly_within","","",26,{"inputs":[{"name":"self"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",25,{"inputs":[{"name":"self"},{"name":"p2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_roughly_within","","",22,{"inputs":[{"name":"self"},{"name":"v2"},{"name":"n"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"boundingbox"}}],[11,"infinite","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"overlaps","","",10,{"inputs":[{"name":"self"},{"name":"boundingbox"}],"output":{"name":"bool"}}],[11,"point","","",10,{"inputs":[{"name":"p2"}],"output":{"name":"self"}}],[11,"grown_by","","",10,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"self"}}],[11,"sum","","",10,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"scan_segments","","",11,{"inputs":[{"name":"startoffsetstate"},{"name":"segment"}],"output":{"name":"option"}}],[11,"segments_with_start_offsets","","",11,{"inputs":[{"name":"self"}],"output":{"name":"scan"}}],[11,"find_on_segment","","",11,{"inputs":[{"name":"self"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains","","",11,{"inputs":[{"name":"self"},{"name":"p2"}],"output":{"name":"bool"}}],[11,"self_intersections","","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}]],"paths":[[8,"Dot"],[8,"ToHomogeneous"],[8,"Norm"],[8,"Inverse"],[8,"Rotate"],[3,"Circle"],[3,"Line"],[3,"Segment"],[3,"Intersection"],[3,"Band"],[3,"BoundingBox"],[8,"Path"],[8,"Intersect"],[8,"WithUniqueOrthogonal"],[8,"RelativeToBasis"],[8,"Into2d"],[8,"Into3d"],[8,"RoughlyComparable"],[8,"Curve"],[8,"FiniteCurve"],[8,"Shape"],[8,"HasBoundingBox"],[6,"V2"],[6,"V3"],[6,"P3"],[6,"P2"],[6,"N"]]};
searchIndex["kay"] = {"doc":"`Kay` is a high-performance actor system, suitable for simulating millions of entities.","items":[[3,"Packet","kay","Combination of a message and its destination recipient id",null,null],[12,"recipient_id","","ID of the `Actor`/`SubActor` that should receive this message",0,null],[12,"message","","The message itself",0,null],[3,"ID","","An ID that uniquely identifies an `Actor`, or even a `SubActor` within a `Swarm`",null,null],[12,"type_id","","An ID for the type of the identified `Actor`, used to dispatch messages to the message handling functions registered for this type",1,null],[12,"machine","","For future use: ID for the machine in a computing cluster or multiplayer environment that the identified `Actor` lives on",1,null],[12,"version","","For future use: allows safe reuse of an ID after `Actor`/`SubActor` death. The version is incremented to make the new (otherwise same) ID distinguishable from erroneous references to the `Actor`/`SubActor` previously identified",1,null],[12,"sub_actor_id","","Used to identify sub-actors within a top-level `Actor`. The main use-case is `Swarm` identifying and dispatching to its `SubActors` using this field",1,null],[3,"ActorSystem","","The main thing inside of which all the magic happens.",null,null],[3,"ActorDefiner","","Helper that is used to define actor behaviour (message handlers).",null,null],[3,"World","","Gives limited access to an `ActorSystem` (typically from inside, in a message handler) to identify other actors and send messages to them.",null,null],[4,"Fate","","Return type of message handling functions, signifying if an `Actor`/`SubActor` should live on after receiving a certain message type.",null,null],[13,"Live","","Means: the `Actor`/`SubActor` should live on",2,null],[13,"Die","","Means: the `Actor`/`SubActor` should be stopped, its state can be deallocated",2,null],[0,"swarm","","Tools for dealing with large amounts of identical actors",null,null],[3,"Swarm","kay::swarm","A container-like actor, housing many sub-actors of identical behaviour.",null,null],[3,"Create","","A message for adding a new sub-actor to a `Swarm` given its initial state.",null,null],[12,"0","","",3,null],[3,"CreateWith","","A message for adding a new sub-actor to a `Swarm` given its initial state and an initial message that the sub-actor will handle immediately after creation.",null,null],[12,"0","","",4,null],[12,"1","","",4,null],[3,"ToRandom","","A wrapper for messages to send a message to a random subset of the sub-actors of a `Swarm`.",null,null],[12,"message","","Actual message that should be handled",5,null],[12,"n_recipients","","Number of randomly selected sub-actors that will receive the message",5,null],[3,"SubActorDefiner","","Helper that is used to define behaviour (message handlers) of sub-actors in a `Swarm`. Analogous to `ActorDefiner` but with some `Swarm`-related extras.",null,null],[8,"StorageAware","","Trait that allows dynamically sized `SubActors` to provide a \"typical size\" hint to optimize their storage in a `Swarm`",null,null],[11,"typical_size","","The default implementation just returns the static size of the implementing type",6,{"inputs":[],"output":{"name":"usize"}}],[8,"SubActor","","Trait that sub-actors of a `Swarm` have to implement so their internally stored sub-actor ID can be gotten and set.",null,null],[10,"id","","Get the full ID (Swarm type id + sub-actor id) of `self`",7,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[10,"set_id","","Set the full ID (Swarm type id + sub-actor id) of `self` (called internally by `Swarm`)",7,{"inputs":[{"name":"self"},{"name":"id"}],"output":null}],[11,"new","","Create an empty `Swarm`.",8,{"inputs":[],"output":{"name":"self"}}],[11,"subactors","","Define message handlers for subactors of a `Swarm` when it is added to a system or extended. See `SubActorDefiner` to see what can be defined.",8,null],[11,"is_still_compact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",3,null],[11,"decompact","","",3,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"create"}}],[11,"is_still_compact","","",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",4,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",4,null],[11,"decompact","","",4,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"createwith"}}],[11,"is_still_compact","","",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",5,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",5,null],[11,"decompact","","",5,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"torandom"}}],[11,"on","","Analogous to `ActorDefiner::on`, the closure argument is passed:",9,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"on_critical","","Same as `on` but continues to receive after the ActorSystem panicked. (Analogous to `ActorDefiner::on_critical`)",9,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"on_create_with","","Allows sub-actors to be created with a particular message (the one handled by the given closure) as an initial message.",9,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"on_random","","Allows a message (the one handled by the given closure) to be received by a random subset of the sub-actors of a `Swarm`.",9,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"world","","Access a `World` of the system that a sub-actor is being defined in, can be used to identify actors (and keep the ID) or send messages at define-time.",9,{"inputs":[{"name":"self"}],"output":{"name":"world"}}],[11,"on_packet","","Advanced: Can be used to register a handler not only for a message, but for a whole packet (precise recipient id + message).",9,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"is_still_compact","kay","",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"dynamic_size_bytes","","",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"compact_from","","",0,null],[11,"decompact","","",0,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"packet"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"id"}],"output":{"name":"bool"}}],[11,"hash","","",1,null],[11,"new","","Create a new ID",1,{"inputs":[{"name":"shorttypeid"},{"name":"u32"},{"name":"u8"}],"output":{"name":"self"}}],[11,"broadcast","","Get a version of an actor ID that signals that a message should be delivered to all sub-actors of that actor, like in the case of a `Swarm`.",1,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new ActorSystem (usually only one per application is needed). Expects to get a panic callback as a parameter that is called when an actor panics during message handling and can thus be used to for example display the panic error message.",10,{"inputs":[{"name":"box"}],"output":{"name":"actorsystem"}}],[11,"add","","Add a new actor to the system given an initial actor state and a closure that takes an ActorDefiner to define message handlers for this actor.",10,{"inputs":[{"name":"self"},{"name":"a"},{"name":"d"}],"output":null}],[11,"extend","","Extend a previously added actor using a closure that takes an ActorDefiner to define additional message handlers for this actor.",10,{"inputs":[{"name":"self"},{"name":"d"}],"output":null}],[11,"send","","Send a message to the actor with a given `ID`. This is only used to send messages into the system from outside. Inside actor message handlers you always have access to a `World` that allows you to send messages.",10,{"inputs":[{"name":"self"},{"name":"id"},{"name":"m"}],"output":null}],[11,"id","","Get the ID of a previously added actor. This is only used to identify actors from the outside. Inside actor message handlers you always have access to a `World` that allows you to identify actors.",10,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"process_all_messages","","Processes all sent messages, and messages which are in turn sent during the handling of messages, up to a recursion depth of 1000.",10,{"inputs":[{"name":"self"}],"output":null}],[11,"on","","Attach a new message handler to an actor, defined by a closure which will receive 3 arguments:",11,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"on_critical","","Same as `on` but continues to receive after the ActorSystem panicked.",11,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"world","","Access a `World` of the system that an actor is being defined in, can be used to identify actors (and keep the ID) or send messages at define-time.",11,{"inputs":[{"name":"self"}],"output":{"name":"world"}}],[11,"on_packet","","Advanced: Can be used to register a handler not only for a message, but for a whole packet (precise recipient id + message), in case a particular sub-actor needs to be identified in the handler, like `Swarm` does.",11,{"inputs":[{"name":"self"},{"name":"f"},{"name":"bool"}],"output":null}],[11,"send","","Send a message to a (sub-)actor with the given ID.",12,{"inputs":[{"name":"self"},{"name":"id"},{"name":"m"}],"output":null}],[11,"id","","Identify an actor based on type.",12,{"inputs":[{"name":"self"}],"output":{"name":"id"}}],[11,"send_to_id_of","","Shorthand for identifying an actor and then sending a message to it.",12,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[11,"broadcast_to_id_of","","Shorthand to broadcast something to all subactors of a `Swarm`.",12,{"inputs":[{"name":"self"},{"name":"m"}],"output":null}],[8,"Message","","Trait that a datastructure must implement in order to be sent and received as a message.",null,null]],"paths":[[3,"Packet"],[3,"ID"],[4,"Fate"],[3,"Create"],[3,"CreateWith"],[3,"ToRandom"],[8,"StorageAware"],[8,"SubActor"],[3,"Swarm"],[3,"SubActorDefiner"],[3,"ActorSystem"],[3,"ActorDefiner"],[3,"World"]]};
searchIndex["kay_macros"] = {"doc":"Automatic `#[derive(SubActor)]` macro for structs which have an `_id: Option<ID>` field.","items":[[5,"derive_actor","kay_macros","",null,{"inputs":[{"name":"tokenstream"}],"output":{"name":"tokenstream"}}]],"paths":[]};
initSearch(searchIndex);
